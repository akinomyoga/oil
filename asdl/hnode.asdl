# Homogeneous tree for pretty-printing ASDL schemas!
# To avoid bootstrapping problems, it can't be pretty-printed!
# It's generated first with a special flag.

module hnode {

  color =
    TypeName
  | StringConst
  | OtherConst
  | UserType  # e.g. for Id
  | External

  Field = (str name, hnode val)

  # Cases:
  # - Full Record
  #   - product type
  #   - sum type - do we need tag?
  # - abbreviated record like Token, CompoundWord
  #   - unnamed fields
  # - List
  #   [1 2 3]
  # - List subtype - with tag
  #   (Foo [1 2 3])
  #   
  # - Dict
  #   - right now this is [Dict k:v] - change it to {k: v} I think
  # - Dict subtype
  #
  # can it be more like NIL8?
  #   (Point x: 42 y: 52)
  #   [a b c]
  #   {k:v k2:v2}
  #   (CompoundWord [1 2 3])
  #   (Dict {a:1 b2})
  #
  #   <Id.Lit_Chars "a">
  #   CompoundWord - {<Id.Lit_Chars "a">}
  # I might change those to
  # <T Lit_Chars a>
  # <w <T LitChars a>>

  hnode =
    # Used to prevent infinite loops
    AlreadySeen(int heap_id)

    # node.abbrev means we print the unnamed fields only - e.g.
    # syntax_abbrev.py sets it
    #
    # A tighter representation might be
    #   record_child = Named(List[Field])
    #                | Unnamed(List[hnode])
    # I guess we want Field in addition to Leaf()?  To avoid breaking it
    #
    # Token is abbreviated <Id.Lit_EscapedChar "\\">  (node_type is removed)

  | Record(str node_type,
           str left, str right,
           List[Field] fields,
           List[hnode]? unnamed_fields)
  | Array(List[hnode] children)
  | Subtype(str node_type, List[hnode] children)

    # note: an ASDL Dict is pretty printed as pairs of Leaf:hnode_t, not Field
  | Leaf(str s, color color)
    # Used for a few value_t variants like value.BuiltinFunc, that point back
    # to mycpp classes
  | External(any obj)

  # NIL8 pretty-printing -- see doc/pretty-printing.md

  # Idea for bit flags for CreateNull().  NOT part of pretty printing / hnode.
  # We just use a single param alloc_lists=True now

  alloc_members =
    List
  | Dict
  | Struct  # ASDL product or sum types
  generate [bit_set]
  # Could also generate alloc_members_b::{None,All}
  
  # Related:
  # - it would be nice to have ASDL value types (pass by value),
  #   e.g. val[Token] or inline[Token]
  # - we should be able to pack i8, i16, u8, u16, or even bitfields
  #   Point = (int x, int y)
  #   Point = (int[signed, 16] x, int[unsigned, 8] y)
  # It's not i16 and u8 because we recognize C++ implicit int conversions. 
  # This is storage only.
}
