// prebuilt/core/error.mycpp.cc: GENERATED by mycpp

#include "prebuilt/core/error.mycpp.h"
// BEGIN mycpp output

#include "mycpp/runtime.h"

namespace runtime {  // forward declare

  class TraversalState;

}  // forward declare namespace runtime

namespace num {  // forward declare


}  // forward declare namespace num

GLOBAL_STR(str0, "(");
GLOBAL_STR(str1, ")");
GLOBAL_STR(str2, "_");
GLOBAL_STR(str3, "T");
GLOBAL_STR(str4, "F");
GLOBAL_STR(str5, "A parse error that can be formatted.\n\n    Formatting is in ui.PrintError.\n    ");
GLOBAL_STR(str6, "For flag parsing errors in builtins and main()\n\n    Called by e_usage().  TODO: Should settle on a single interface that\n    can be translated.  Sometimes we use 'raise error.Usage()'\n    ");
GLOBAL_STR(str7, "Used in the parsers.");
GLOBAL_STR(str8, "Raised when a glob matches nothing when failglob is set.\n\n    Meant to be caught.\n    ");
GLOBAL_STR(str9, "Used in the CommandEvaluator.\n\n    A bad redirect causes the SimpleCommand to return with status 1.  To\n    make it fatal, use set -o errexit.\n    ");
GLOBAL_STR(str10, "An exception that propagates to the top level.\n\n    Used in the evaluators, and also also used in test builtin for\n    invalid argument.\n    ");
GLOBAL_STR(str11, "Depending on shell options, these errors may be caught and ignored.\n\n    For example, if options like these are ON:\n\n      set -o strict_arith\n      set -o strict_word_eval\n\n    then we re-raise the error so it's caught by the top level.  Otherwise\n    we catch it and return a dummy value like '' or -1 (i.e. what bash commonly\n    does.)\n\n    TODO: Have levels, like:\n\n    OILS_STRICT_PRINT=2   # print warnings at level 2 and above\n    OILS_STRICT_DIE=1  # abort the program at level 1 and above\n    ");
GLOBAL_STR(str12, "For set -e.\n\n    Travels between WordEvaluator and CommandEvaluator.\n    ");
GLOBAL_STR(str13, "e.g. KeyError, IndexError, ZeroDivisionError.");
GLOBAL_STR(str14, "An error that can be exposed via the _error Dict.\n\n    Including:\n    - Errors raised by the 'error' builtin\n    - J8 encode and decode errors.\n    ");
GLOBAL_STR(str15, "code");
GLOBAL_STR(str16, "message");
GLOBAL_STR(str17, "An assertion.");
GLOBAL_STR(str18, "e.g. ~ on a bool or float, 'not' on an int.");
GLOBAL_STR(str19, "%s, got %s");
GLOBAL_STR(str20, "An error that's meant to be caught, i.e. it's non-fatal.\n\n    Thrown by core/state.py and caught by builtins\n    ");
GLOBAL_STR(str21, "\n    List of J8 errors:\n    - message isn't UTF-8 - Id.Lit_Chars - need loc\n    - Invalid token Id.Unkown_Tok - need loc\n    - Unclosed double quote string -- need loc\n    - Parse error, e.g. [}{]\n\n    - Invalid escapes:\n      - b\"\" and u\"\" don't accept \\u1234\n      - u\"\" doesn't accept \\yff\n      - \"\" doesn't accept \\yff or \\u{123456}\n    ");
GLOBAL_STR(str22, " (line %d, offset %d-%d: %r)");
GLOBAL_STR(str23, "\n    List of J8 encode errors:\n    - object cycle\n    - unprintable object like Eggex\n    When encoding JSON:\n    - binary data that can't be represented in JSON\n      - if using Unicode replacement char, then it won't fail\n    ");

namespace runtime {  // declare

using hnode_asdl::hnode;
extern int NO_SPID;
hnode::Record* NewRecord(BigStr* node_type);
hnode::Leaf* NewLeaf(BigStr* s, hnode_asdl::color_t e_color);
class TraversalState {
 public:
  TraversalState();
  Dict<int, bool>* seen{};
  Dict<int, int>* ref_count{};

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(TraversalState));
  }

  DISALLOW_COPY_AND_ASSIGN(TraversalState)
};

extern BigStr* TRUE_STR;
extern BigStr* FALSE_STR;

}  // declare namespace runtime

namespace num {  // declare

value::Int* ToBig(int i);
mops::BigInt Exponent(mops::BigInt x, mops::BigInt y);

}  // declare namespace num

namespace runtime {  // define

using hnode_asdl::hnode;
using hnode_asdl::color_t;
using hnode_asdl::color_e;
int NO_SPID = -1;

hnode::Record* NewRecord(BigStr* node_type) {
  StackRoot _root0(&node_type);

  return Alloc<hnode::Record>(node_type, str0, str1, Alloc<List<hnode_asdl::Field*>>(), nullptr);
}

hnode::Leaf* NewLeaf(BigStr* s, hnode_asdl::color_t e_color) {
  StackRoot _root0(&s);

  if (s == nullptr) {
    return Alloc<hnode::Leaf>(str2, color_e::OtherConst);
  }
  else {
    return Alloc<hnode::Leaf>(s, e_color);
  }
}

TraversalState::TraversalState() {
  this->seen = Alloc<Dict<int, bool>>();
  this->ref_count = Alloc<Dict<int, int>>();
}
BigStr* TRUE_STR = str3;
BigStr* FALSE_STR = str4;

}  // define namespace runtime

namespace error {  // define

using syntax_asdl::loc_e;
using syntax_asdl::loc_t;
using syntax_asdl::loc;
using value_asdl::value;
using value_asdl::value_t;
using value_asdl::value_str;

BigStr* _ValType(value_asdl::value_t* val) {
  StackRoot _root0(&val);

  return value_str(val->tag(), false);
}

_ErrorWithLocation::_ErrorWithLocation(BigStr* msg, syntax_asdl::loc_t* location) {
  this->msg = msg;
  if (location == nullptr) {
    this->location = loc::Missing;
  }
  else {
    this->location = location;
  }
}

bool _ErrorWithLocation::HasLocation() {
  return this->location->tag() != loc_e::Missing;
}

BigStr* _ErrorWithLocation::UserErrorString() {
  return this->msg;
}

Usage::Usage(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

Parse::Parse(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

FailGlob::FailGlob(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

RedirectEval::RedirectEval(BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
}

FatalRuntime::FatalRuntime(int exit_status, BigStr* msg, syntax_asdl::loc_t* location) : ::error::_ErrorWithLocation(msg, location) {
  this->exit_status = exit_status;
}

int FatalRuntime::ExitStatus() {
  return this->exit_status;
}

Strict::Strict(BigStr* msg, syntax_asdl::loc_t* location) : ::error::FatalRuntime(1, msg, location) {
}

ErrExit::ErrExit(int exit_status, BigStr* msg, syntax_asdl::loc_t* location, bool show_code) : ::error::FatalRuntime(exit_status, msg, location) {
  this->show_code = show_code;
}

Expr::Expr(BigStr* msg, syntax_asdl::loc_t* location) : ::error::FatalRuntime(3, msg, location) {
}

Structured::Structured(int status, BigStr* msg, syntax_asdl::loc_t* location, Dict<BigStr*, value_asdl::value_t*>* properties) : ::error::FatalRuntime(status, msg, location) {
  this->properties = properties;
}

value::Dict* Structured::ToDict() {
  Dict<BigStr*, value_asdl::value_t*>* d = nullptr;
  StackRoot _root0(&d);

  d = Alloc<Dict<BigStr*, value_asdl::value_t*>>();
  if (this->properties != nullptr) {
    d->update(this->properties);
  }
  d->set(str15, num::ToBig(this->ExitStatus()));
  d->set(str16, Alloc<value::Str>(this->msg));
  return Alloc<value::Dict>(d);
}

AssertionErr::AssertionErr(BigStr* msg, syntax_asdl::loc_t* location) : ::error::Expr(msg, location) {
}

TypeErrVerbose::TypeErrVerbose(BigStr* msg, syntax_asdl::loc_t* location) : ::error::Expr(msg, location) {
}

TypeErr::TypeErr(value_asdl::value_t* actual_val, BigStr* msg, syntax_asdl::loc_t* location) : ::error::TypeErrVerbose(StrFormat("%s, got %s", msg, _ValType(actual_val)), location) {
}

Runtime::Runtime(BigStr* msg) {
  this->msg = msg;
}

BigStr* Runtime::UserErrorString() {
  return this->msg;
}

Decode::Decode(BigStr* msg, BigStr* s, int start_pos, int end_pos, int line_num) {
  this->msg = msg;
  this->s = s;
  this->start_pos = start_pos;
  this->end_pos = end_pos;
  this->line_num = line_num;
}

BigStr* Decode::Message() {
  int start;
  int end;
  BigStr* part = nullptr;
  StackRoot _root0(&part);

  start = max(0, (this->start_pos - 4));
  end = min(len(this->s), (this->end_pos + 4));
  part = this->s->slice(start, end);
  return str_concat(this->msg, StrFormat(" (line %d, offset %d-%d: %r)", this->line_num, this->start_pos, this->end_pos, part));
}

BigStr* Decode::__str__() {
  return this->Message();
}

Encode::Encode(BigStr* msg) {
  this->msg = msg;
}

BigStr* Encode::Message() {
  return this->msg;
}

[[noreturn]] void e_usage(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Usage>(msg, location);
}

[[noreturn]] void e_strict(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Strict>(msg, location);
}

[[noreturn]] void p_die(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<Parse>(msg, location);
}

[[noreturn]] void e_die(BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<FatalRuntime>(1, msg, location);
}

[[noreturn]] void e_die_status(int status, BigStr* msg, syntax_asdl::loc_t* location) {
  StackRoot _root0(&msg);
  StackRoot _root1(&location);

  throw Alloc<FatalRuntime>(status, msg, location);
}

}  // define namespace error

namespace num {  // define

using value_asdl::value;

value::Int* ToBig(int i) {
  return Alloc<value::Int>(mops::IntWiden(i));
}

mops::BigInt Exponent(mops::BigInt x, mops::BigInt y) {
  int y_int;
  mops::BigInt result;
  y_int = mops::BigTruncate(y);
  result = mops::BigInt(1);
  for (int i = 0; i < y_int; ++i) {
    result = mops::Mul(result, x);
  }
  return result;
}

}  // define namespace num

